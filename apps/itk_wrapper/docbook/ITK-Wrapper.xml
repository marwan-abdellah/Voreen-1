<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article [
<!ENTITY % global.entities SYSTEM "../../../system/custom-xsl/global-entities.xml">
%global.entities;
<!ENTITY % entities SYSTEM "../custom-cfg/local-entities.xml">
%entities;
]>
<article version="5.0" xml:lang="en" xmlns="http://docbook.org/ns/docbook"
         xmlns:ns6="http://www.w3.org/1999/xlink"
         xmlns:ns5="http://www.w3.org/2000/svg"
         xmlns:ns4="http://www.w3.org/1998/Math/MathML"
         xmlns:ns3="http://www.w3.org/1999/xhtml"
         xmlns:ns="http://docbook.org/ns/docbook">
  <info>
    <title>Voreen ITK-Wrapper Manual</title>

    <author>
      <personname><firstname>Mathias</firstname><surname>Dehne</surname></personname>
    </author>

    <author>
      <personname><firstname>Maike</firstname><surname>Dudek</surname></personname>
    </author>

    <revhistory>
      <revision>
        <revnumber>1.0</revnumber>

        <date>12.10.2011</date>
      </revision>
    </revhistory>
  </info>

  <sect1>
    <title>Introduction</title>

    <para>The <link ns6:href="http://www.itk.org">Insight Segmentation and
    Registration Toolkit (ITK)</link> is an open-source software toolkit
    containing an extensive suite of software tools for image analysis. It
    provides the developer with a large number of image-to-image filters
    ranging from basic filtering operations to more advanced segmentation- and
    registration frameworks. The ITK-Wrapper was developed as an easy to use
    interface for integration of these filters into <link
    ns6:href="http://www.voreen.org">Voreen</link> project. To achieve this
    the ITK-Wrapper provides the functionality to deserialize special XML
    config files containing ITK filter definitions to filter objects. These
    filter objects are then used to automatically generate the actual code for
    the corresponding Voreen processor where in- and outputs of an ITK filter
    are mapped to Voreen ports and the attributes of a filter are mapped to
    Voreen properties.</para>
  </sect1>

  <sect1>
    <title>Getting Started</title>

    <para>The ITK-Wrapper is located in
    "<filename>apps/itk_wrapper</filename>" in the voreen directory. It
    contains:</para>

    <itemizedlist>
      <listitem>
        <para>a Qt-project-file "<filename>itk_wrapper.pro</filename>"</para>
      </listitem>

      <listitem>
        <para>the ITK-Wrapper <filename>.cpp</filename>- an
        <filename>.h</filename>- files "<filename>itk_wrapper</filename>",
        "<filename>baseclasses</filename>" and
        "<filename>template</filename>"</para>
      </listitem>

      <listitem>
        <para>the <filename>xml_Files</filename> directory, containing the XML
        files where the ITK filter-definitions are stored</para>
      </listitem>

      <listitem>
        <para>the <filename>template</filename> directory, with the general
        template text files for the Voreen processor generation</para>
      </listitem>

      <listitem>
        <para>the <filename>specialFilters</filename> folder storing filters
        that cannot be generated automatically</para>
      </listitem>
    </itemizedlist>

    <para>By default all XML files in the directory
    <filename>xml_Files</filename> are processed by the wrapper, generating
    all predefined filters. Additionally It is possible to use only a specific
    set of XML files. An example on the actual use of this option can be found
    in the main method of <filename>itk_wrapper.cpp</filename>. The generated
    Voreen processors are copied to
    "<filename>module/itk_generated/processors</filename>" in the voreen
    directory .</para>

    <para>Apart from the processor files the wrapper generates the files
    <filename role="bold">itk_generatedmodule.cpp</filename>,
    <filename>itk_generated_core.pri</filename> and the
    <filename>itk_generated_module.xml</filename>.</para>

    <para>In order to use the generated ITK processors the
    <filename>itk_generated</filename> module needs to be included. The
    following line has to be added to the Voreen config.txt:</para>

    <programlisting>VRN_MODULES += itk_generated</programlisting>

    <para><emphasis role="bold">Note:</emphasis>
    <filename>itk_generated</filename> module depends on
    <filename>itk</filename> module. Thus activation of the itk module in the
    <filename>config.txt</filename> is mandatory for using the itk_generated
    module.</para>
  </sect1>

  <sect1>
    <title>Adding new ITK-filters</title>

    <para>Now you know how to generate the Voreen processors representing the
    already defined ITK filters with the ITK-Wrapper. But what about adding
    new filters?</para>

    <para>To add a new ITK filter you have to define the filter in its module
    XML file. To understand the XML filestructure it is described in the next
    section.</para>

    <para>Section 3.2 shows some examples of already added filters and section
    3.3 explains how to add a more difficult filter which cannot be generated
    automatically by the wrapper (special filter).</para>

    <sect2>
      <title>XML-File-Structure</title>

      <para>In order to find a specific ITK filter in Voreen, we used the
      <link
      ns6:href="http://www.itk.org/Doxygen/html/modules.html">ITK-Doxygen</link>
      structure. All filters are subsumed under different groups which contain
      different modules. For example, there is the group "Filtering" which
      contains the modules "ITKAnisotropicSmoothing", "ITKImageFeature" and so
      on. Thus each XML file in the <filename>xml_Files</filename> directory
      of the ITK-Wrapper represents one module of the ITK-Doxygen structure.
      (The group to which a module belongs is defined in the associated XML
      file itself).</para>

      <para>The inner structure of such an XML file is structured as
      followed:</para>

      <para>First the <emphasis role="bold">xml version</emphasis> and the
      <emphasis role="bold">VoreenData</emphasis> version need to be
      declared:</para>

      <programlisting>&lt;?xml version="1.0" ?&gt;
&lt;VoreenData version="1"&gt;</programlisting>

      <para>After that the <emphasis role="bold">ITK_Module</emphasis> is
      defined through a <emphasis role="bold">name</emphasis> ("itk_" followed
      by the name of the module, e.g. "AnisotropicSmoothing"), a <emphasis
      role="bold">group</emphasis> (e.g. "Filtering") and a <emphasis
      role="bold">filterlist</emphasis> containing the <emphasis
      role="bold">filters</emphasis> of the module:</para>

      <programlisting>  &lt;ITK_Module name="itk_AnisotropicSmoothing" group="Filtering"&gt;
    &lt;filterlist&gt;
      &lt;filter ...&gt;
      &lt;/filter&gt;
      ...
    &lt;/filterlist&gt;
  &lt;/ITK_Module&gt;
&lt;/VoreenData&gt;</programlisting>

      <para>Each <emphasis role="bold">filter</emphasis> element is then
      described through a number of XML attributes and -child elements:</para>

      <variablelist>
        <varlistentry>
          <term><emphasis role="bold">name</emphasis></term>

          <listitem>
            <para>Name of the filter, e.g.
            "CurvatureAnisotropicDiffusionImageFilter"</para>

            <para><emphasis role="bold">Note:</emphasis> The name must be
            exactly the name of the ITK filter, otherwise it will not
            work!</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><emphasis role="bold">enabled (optional)</emphasis></term>

          <listitem>
            <para>Boolean to enable or disable a filter. Default value is
            <emphasis>true</emphasis>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><emphasis role="bold">description (optional)</emphasis></term>

          <listitem>
            <para>If a filter is disabled the description attribute can be set
            to describe why the filter is disabled. Otherwise the description
            is taken as the processor description in Voreen. If the filter is
            enabled and no description is set, the wrapper will generate a
            link to the ITK Doxygen page of the filter (by using the name of
            the filter) as processor description.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><emphasis role="bold">autoGenerated
          (optional)</emphasis></term>

          <listitem>
            <para>Boolean whether the filter can be auto generated by the
            wrapper or not (see "3.3 Special Filters"). Default value is
            <emphasis>true</emphasis>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><emphasis role="bold">codeState (optional)</emphasis></term>

          <listitem>
            <para>Code state of a filter.</para>

            <para>Possible values are <emphasis>EXPERIMENTAL</emphasis>,
            <emphasis>TESTING</emphasis> and <emphasis>STABLE</emphasis>.
            Default value is <emphasis>EXPERIMENTAL</emphasis>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><emphasis role="bold">inports (optional)</emphasis></term>

          <listitem>
            <para>Child element containing the inports / inputs of a filter.
            See <emphasis role="bold">port</emphasis>.</para>

            <para><emphasis role="bold">Note:</emphasis> By default a filter
            has one inport and one outport, which support all scalar volume
            types. It is only necessary to set the ports of a filter if it has
            more or less than one in- and/or outport or if the port supports
            only specific volume types. If you set one port of the filter
            (inport or outport) you have to set all ports of the filter.As an
            example: If you have a filter which has volume type constraints
            for the inport you nevertheless have to set the outport.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><emphasis role="bold">outports (optional)</emphasis></term>

          <listitem>
            <para>Child element of a <emphasis role="bold">filter</emphasis>
            containing the outports / outputs of a filter. See <emphasis
            role="bold">port</emphasis>.</para>

            <para><emphasis role="bold">Note 1:</emphasis> By default a filter
            has one inport and one outport, which allow all scalar volume
            types. So you only have to set the ports of a filter if it has
            more or less than one in- or outport or if there are only special
            volume types supported for the port. But if you set one port of
            the filter (inport or outport) you have to set all ports of the
            filter! So if there is for example a filter which has volume type
            constraints only on the inport you nevertheless have to set the
            outport.</para>

            <para><emphasis role="bold">Note 2:</emphasis> You can only set
            one type for the possibleTypes of an outport (e.g.
            <emphasis>UInt8</emphasis>). If there is a volume type constraint
            on the inport, for example <emphasis>IntegerScalar,</emphasis> and
            you want the output of the outport to be from the same type as the
            input of the inport you don't have to set the possibleTypes of the
            outport. This ensures that the output is of the same type as the
            input.</para>

            <variablelist>
              <varlistentry>
                <term><emphasis role="bold">port</emphasis></term>

                <listitem>
                  <para>Child element of <emphasis
                  role="bold">inports</emphasis> element or <emphasis
                  role="bold">outports</emphasis> element containing the
                  attributes and child elements:</para>

                  <variablelist>
                    <varlistentry>
                      <term><emphasis role="bold">name</emphasis></term>

                      <listitem>
                        <para>Name of an inport or outport of a filter, e.g.
                        "InputImage"</para>
                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term><emphasis role="bold">filterTemplate
                      (optional)</emphasis></term>

                      <listitem>
                        <para>Boolean defining whether the port is a template
                        argument of the filter or not. Default value is
                        <emphasis>true</emphasis>.</para>

                        <para>This attribute is necessary if for example a
                        filter has two inports and one outport but only one
                        template argument because all ports have to be from
                        the same volume type.</para>
                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term><emphasis role="bold">nameIsSetter
                      (optional)</emphasis></term>

                      <listitem>
                        <para>Boolean defining whether the name of the port is
                        the filter input setter of or not. Default value is
                        <emphasis>false</emphasis>.</para>

                        <para>Usually the inputs of a filter are set with
                        "SetInput1(...);", "SetInput2(...);" and so on (or
                        only with "SetInput(..);" if there is only one input)
                        but sometimes a special name is needed to set an
                        input, e.g. "SetMaskImage(...)". In this case the name
                        of the inport (here "MaskImage") can be used to set
                        the input.</para>
                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term><emphasis role="bold">transferRWM
                      (optional)</emphasis></term>

                      <listitem>
                        <para>Boolean defining whether the RealWorldMapping of the input dataset is applied to this outport or not. Default value is
                        <emphasis>true</emphasis>.</para>

                        <para> Where the output has a different interpretation (segmentation id, color) then the input, this should be set to false.
                        </para>
                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term><emphasis role="bold">transferTransformation
                      (optional)</emphasis></term>

                      <listitem>
                        <para>Boolean defining whether the PhysicalToWorld matrix of the input dataset is applied to this outport or not. Default value is
                        <emphasis>true</emphasis>.</para>

                        <para> Can't think of a reason to disable this...
                        </para>
                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term><emphasis
                      role="bold">possibleTypes</emphasis></term>

                      <listitem>
                        <para>Child element of a <emphasis
                        role="bold">port</emphasis> containing the possible
                        volume types of the port.</para>

                        <para>Possible values for a volume <emphasis
                        role="bold">type</emphasis> are
                        <emphasis>UInt8</emphasis>, <emphasis>Int8</emphasis>,
                        <emphasis>UInt16</emphasis>,
                        <emphasis>Int16</emphasis>,
                        <emphasis>UInt32</emphasis>,
                        <emphasis>Int32</emphasis>,
                        <emphasis>UInt64</emphasis>,
                        <emphasis>Int64</emphasis>,
                        <emphasis>Float</emphasis>,
                        <emphasis>Double</emphasis>,
                        <emphasis>4xUInt8</emphasis>,
                        <emphasis>4xInt8</emphasis>,
                        <emphasis>4xUInt16</emphasis>,
                        <emphasis>4xInt16</emphasis>,
                        <emphasis>4xFloat</emphasis>,
                        <emphasis>4xDouble</emphasis>,
                        <emphasis>3xUInt8</emphasis>,
                        <emphasis>3xInt8</emphasis>,
                        <emphasis>3xUInt16</emphasis>,
                        <emphasis>3xInt16</emphasis>,
                        <emphasis>3xFloat</emphasis>,
                        <emphasis>3xDouble</emphasis>,
                        <emphasis>2xUInt8</emphasis>,
                        <emphasis>2xInt8</emphasis>,
                        <emphasis>2xUInt16</emphasis>,
                        <emphasis>2xInt16</emphasis>,
                        <emphasis>2xFloat</emphasis>,
                        <emphasis>2xDouble</emphasis>, or the metaTypes
                        <emphasis>Scalar</emphasis> (which contains all scalar
                        volume types apart from <emphasis>UInt64</emphasis>
                        and <emphasis>Int64</emphasis>),
                        <emphasis>IntegerScalar</emphasis> (which contains all
                        scalar integer volume types apart from
                        <emphasis>UInt64</emphasis> and
                        <emphasis>Int64</emphasis>),
                        <emphasis>RealScalar</emphasis> (which contains all
                        scalar real volume types), <emphasis>Vector</emphasis>
                        (which contains all vector volume types),
                        <emphasis>IntegerVector </emphasis>(which contains all
                        vector integer volume types) and
                        <emphasis>RealVector</emphasis> (which contains all
                        vector real volume types).</para>
                      </listitem>
                    </varlistentry>
                  </variablelist>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><emphasis role="bold">attributes (optional)</emphasis></term>

          <listitem>
            <para>Child element of a <emphasis role="bold">filter</emphasis>
            containing the attributes of a filter:</para>

            <variablelist>
              <varlistentry>
                <term><emphasis role="bold">attribute</emphasis></term>

                <listitem>
                  <para>Child element of <emphasis
                  role="bold">attributes</emphasis> element containing:</para>

                  <variablelist>
                    <varlistentry>
                      <term><emphasis role="bold">name</emphasis></term>

                      <listitem>
                        <para>Name of the attribute, e.g.
                        "NumberOfIterations"</para>
                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term><emphasis
                      role="bold">argumenttype</emphasis></term>

                      <listitem>
                        <para>Type of the argument.</para>

                        <para>Possible values are:</para>

                        <itemizedlist>
                          <listitem>
                            <para><emphasis>Int</emphasis>,
                            <emphasis>Float</emphasis> and
                            <emphasis>Bool</emphasis>: Represented through an
                            Int-, a Float- or a BoolProperty in Voreen.</para>
                          </listitem>

                          <listitem>
                            <para><emphasis>KernelType</emphasis>: Used if a
                            filter has a TKernel as template-argument. This
                            means, that it needs a structuring element as
                            kernel.</para>

                            <para>The ITK-Wrapper then generates a processor
                            where you can choose one of the existing structuring
                            elements through a StringOptionProperty.</para>
                          </listitem>

                          <listitem>
                            <para><emphasis>SizeType</emphasis> and
                            <emphasis>IndexTxpe</emphasis>: Represented through
                            an IntVec3Property in Voreen.</para>
                          </listitem>

                          <listitem>
                            <para><emphasis>ArrayType</emphasis>: Represented
                            through a FloatVec3Property in Voreen.</para>
                          </listitem>

                          <listitem>
                            <para><emphasis>PixelType</emphasis>: Represented
                            through a VoxelTypeProperty in Voreen.</para>
                          </listitem>

                          <listitem>
                            <para><emphasis>SetSeedType</emphasis>: Only used if
                            a filter needs a seed point and has no
                            AddSeed-function!</para>

                            <para>The ITK-Wrapper then generates a processor
                            with a GeometryPort as an additional inport through
                            which seed points can be added. (To do this the
                            SeedpointGenerator- or the VolumePicking processor
                            can be used.) The seed point which should be used as
                            the filter's seed point can be chosen through an
                            IntProperty.</para>
                          </listitem>

                          <listitem>
                            <para><emphasis>AddSeedType</emphasis>: Used if a
                            filter needs one ore more seed point(s).</para>

                            <para>The ITK-Wrapper then generates a processor
                            with a GeometryPort as additional inport through
                            which seed points can be added. (To do this the
                            SeedpointGenerator- or the VolumePicking processor
                            can be used.) All added seed points will be added to
                            the filter as well but some filters only use the
                            first added seed point.</para>
                          </listitem>

                          <listitem>
                            <para><emphasis>VectorSeedType</emphasis>: Used if a
                            filter needs a vector of seed points and has no
                            AddSeed-function.</para>

                            <para>The ITK-Wrapper then generates a processor
                            with a GeometryPort as additional inport through
                            which seed points can be added. (To do this the
                            SeedpointGenerator- or the VolumePicking processor
                            can be used.)</para>
                          </listitem>
                        </itemizedlist>
                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term><emphasis role="bold">inputArgument
                      (optional)</emphasis></term>

                      <listitem>
                        <para>Boolean defining whether the argument is an
                        input- or an output-argument of the filter. Default
                        value is <emphasis>true</emphasis>.</para>
                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term><emphasis
                      role="bold">defaultValue</emphasis></term>

                      <listitem>
                        <para>Default value of the argument. Only needed for
                        the argumenttypes <emphasis>Int</emphasis> (e.g.
                        defaultValue="1"), <emphasis>Float</emphasis> (e.g.
                        defaultValue="1.0f"), <emphasis>Bool </emphasis>(e.g.
                        defaultValue="false"), <emphasis>SizeType</emphasis>
                        and <emphasis>IndexType</emphasis> (e.g.
                        defaultValue="<emphasis
                        role="bold">(</emphasis>1<emphasis
                        role="bold">)</emphasis>") and
                        <emphasis>ArrayType</emphasis> (e.g.
                        defaultValue="<emphasis
                        role="bold">(</emphasis>1.0f<emphasis
                        role="bold">)</emphasis>"). All other argumenttypes
                        don't have a defaultValue.</para>
                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term><emphasis role="bold">minValue</emphasis></term>

                      <listitem>
                        <para>Minimum value of the argument. Only needed for
                        the argumenttypes <emphasis>Int</emphasis>,
                        <emphasis>Float</emphasis>,
                        <emphasis>SizeType</emphasis>,
                        <emphasis>IndexType</emphasis> and <emphasis>Array
                        Type</emphasis> (examples see: defaultValue). For the
                        argumenttype <emphasis>PixelType</emphasis> the
                        minValue is optional (example: value 0 is not
                        allowed).</para>
                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term><emphasis role="bold">maxValue</emphasis></term>

                      <listitem>
                        <para>Maximum value of the argument. Only needed for
                        the argumenttypes <emphasis>Int</emphasis>,
                        <emphasis>Float</emphasis>,
                        <emphasis>SizeType</emphasis>,
                        <emphasis>IndexType</emphasis> and <emphasis>Array
                        Type</emphasis> (examples see: defaultValue). For the
                        argumenttype <emphasis>PixelType</emphasis> the
                        maxValue is optional like the minValue.</para>
                      </listitem>
                    </varlistentry>
                  </variablelist>
                </listitem>
              </varlistentry>
            </variablelist>
          </listitem>
        </varlistentry>
      </variablelist>
    </sect2>

    <sect2>
      <title>Examples</title>

      <para>This section shows some examples of filters which can be generated
      automatically by the ITK-Wrapper. Apart from these examples you can find
      other filter examples in the XML files of the
      <filename>xml_Files</filename> directory where over 150 filters are
      already defined.</para>

      <sect3>
        <title>Example 1: AbsImageFilter - A very simple filter</title>

        <para>One of the simplest filters is the <link
        ns6:href="http://www.itk.org/Doxygen/html/classitk_1_1AbsImageFilter.html">AbsImageFilter</link>
        which can be found in "itk_ImageIntensity.xml" in the
        <filename>xml_Files</filename> directory. This filter has one standard
        inport, one standard outport and no attributes. Therefore it can be
        simply defined like this:</para>

        <programlisting>      &lt;filter name="AbsImageFilter" codeState="STABLE"&gt;
      &lt;/filter&gt;</programlisting>
      </sect3>

      <sect3>
        <title>Example 2: AndImageFiler - A simple filter with two inports and
        volume type constraints</title>

        <para>The <link
        ns6:href="http://www.itk.org/Doxygen/html/classitk_1_1AndImageFilter.html">AndImageFilter</link>
        also can be found in "itk_ImageIntensity.xml" in the xml_Files
        directory. It has two inports and one outport which only allow scalar
        integer volume types and no attributes.</para>

        <programlisting>      &lt;filter name="AndImageFilter" codeState="STABLE"&gt;
        &lt;inports&gt;
          &lt;port name="InputImage1"&gt;
            &lt;possibleTypes&gt;
              &lt;type value="IntegerScalar"/&gt;
            &lt;/possibleTypes&gt;
          &lt;/port&gt;
          &lt;port name="InputImage2"&gt;
            &lt;possibleTypes&gt;
              &lt;type value="IntegerScalar"/&gt;
            &lt;/possibleTypes&gt;
          &lt;/port&gt;
        &lt;/inports&gt;
        &lt;outports&gt;
          &lt;port name="OutputImage"/&gt;
        &lt;/outports&gt;
      &lt;/filter&gt;</programlisting>
      </sect3>

      <sect3>
        <title>Example 3: CheckerBoardImageFilter - A filter where not all
        ports are template-arguments of the filter</title>

        <para>The <link
        ns6:href="http://www.itk.org/Doxygen/html/classitk_1_1CheckerBoardImageFilter.html">CheckerBoardImageFilter</link>
        can be found in "itk_ImageCompare.xml" in the xml_Files directory. It
        has two inports and one outport but only one template argument because
        all ports have to be from the same volume type. Therefore the
        filterTemplate argument needs to be set to false for the second inport
        and the outport.</para>

        <programlisting>      &lt;filter name="CheckerBoardImageFilter" codeState="STABLE"&gt;
        &lt;inports&gt;
          &lt;port name="InputImage1"/&gt;
          &lt;port name="InputImage2" filterTemplate="false"/&gt;
        &lt;/inports&gt;
        &lt;outports&gt;
          &lt;port name="OutputImage" filterTemplate="false"/&gt;
        &lt;/outports&gt;
      &lt;/filter&gt;</programlisting>
      </sect3>

      <sect3>
        <title>Example 4: GrayscaleGeodesicDilateImageFilter - A filter where
        the name of the inport is the name of the input-setter of the
        filter</title>

        <para>The <link
        ns6:href="http://www.itk.org/Doxygen/html/classitk_1_1GrayscaleGeodesicDilateImageFilter.html">GrayscaleGeodesicDilateImageFilter</link>
        can be found in "itk_MathematicalMorphology.xml" in the xml_Files
        directory. It has two inports, one outport and two arguments of the
        type Bool. But this time the names of the inports are needed as
        setters for the inputs of the filter. Apart from this the second input
        is no template argument of the filter because it needs to be from the
        same volume type as the first input.</para>

        <programlisting>      &lt;filter name="GrayscaleGeodesicDilateImageFilter" codeState="STABLE"&gt;
        &lt;inports&gt;
          &lt;port name="MarkerImage" nameIsSetter="true"/&gt;
          &lt;port name="MaskImage" nameIsSetter="true" filterTemplate="false"/&gt;
        &lt;/inports&gt;
        &lt;outports&gt;
          &lt;port name="OutputImage"/&gt;
        &lt;/outports&gt;
        &lt;arguments&gt;
          &lt;argument name="RunOneIteration" argumenttype="Bool" defaultValue="false"/&gt;
          &lt;argument name="FullyConnected" argumenttype="Bool" defaultValue="false"/&gt;
        &lt;/arguments&gt;
      &lt;/filter&gt;</programlisting>
      </sect3>

      <sect3>
        <title>Example 5: GrayscaleDilateImageFilter - A filter with a
        TKernel</title>

        <para>The <link
        ns6:href="http://www.itk.org/Doxygen/html/classitk_1_1GrayscaleDilateImageFilter.html">GrayscaleDilateImageFilter</link>
        can be found in "itk_MathematicalMorphology.xml" in the xml_Files
        directory. It has one standard inport, one standard outport and three
        arguments. The special thing about this filter is, that is has a
        TKernel as template argument. This means, that it needs a structuring
        element as kernel.</para>

        <para>The wrapper therefore generates a processor with a range of
        different structuring elements which can be chosen by a
        StringOptionProperty.</para>

        <programlisting>      &lt;filter name="GrayscaleDilateImageFilter" codeState="STABLE"&gt;
        &lt;arguments&gt;
          &lt;argument name="Kernel" argumenttype="KernelType"/&gt;
          &lt;argument name="Algorithm" argumenttype="Int" defaultValue="0" 
                    minValue="0" maxValue="3"/&gt;
          &lt;argument name="Boundary" argumenttype="PixelType"/&gt;
        &lt;/arguments&gt;
      &lt;/filter&gt;</programlisting>
      </sect3>

      <sect3>
        <title>Example 6: CannyEdgeDetectionImageFilter - A filter with an
        ArrayType-argument</title>

        <para>The <link
        ns6:href="http://www.itk.org/Doxygen/html/classitk_1_1CannyEdgeDetectionImageFilter.html">CannyEdgeDetectionImageFilter</link>
        can be found in "itk_ImageFeature.xml" in the xml_Files directory. It
        has one inport and one outport with a volume type constraint (Float)
        and five arguments where three are from the type
        <emphasis>PixelType</emphasis> and two are from the type
        <emphasis>ArrayType</emphasis>.</para>

        <programlisting>      &lt;filter name="CannyEdgeDetectionImageFilter" codeState="STABLE"&gt;
        &lt;inports&gt;
          &lt;port name="InputImage"&gt;
            &lt;possibleTypes&gt;
              &lt;type value="Float"/&gt;
            &lt;/possibleTypes&gt;
          &lt;/port&gt;
        &lt;/inports&gt;
        &lt;outports&gt;
          &lt;port name="OutputImage"/&gt;
        &lt;/outports&gt;
        &lt;arguments&gt;
          &lt;argument name="LowerThreshold" argumenttype="PixelType"/&gt;
          &lt;argument name="UpperThreshold" argumenttype="PixelType"/&gt;
          &lt;argument name="OutsideValue" argumenttype="PixelType"/&gt;
          &lt;argument name="Variance" argumenttype="ArrayType" defaultValue="(0.1f)" 
                    minValue="(0.0f)" maxValue="(0.99f)"/&gt;
          &lt;argument name="MaximumError" argumenttype="ArrayType" defaultValue="(0.1f)" 
                    minValue="(0.0f)" maxValue="(0.99f)"/&gt;
        &lt;/arguments&gt;
      &lt;/filter&gt;</programlisting>
      </sect3>

      <sect3>
        <title>Example 7: ConfidenceConnectedImageFilter - A
        segmentation-filter which needs a seed point</title>

        <para>The <link
        ns6:href="http://www.itk.org/Doxygen/html/classitk_1_1ConfidenceConnectedImageFilter.html">ConfidenceConnectedImageFilter</link>
        can be found in "itk_RegionGrowing.xml" in the xml_Files directory. It
        has one standard inport, one standard outport and five arguments. To
        find a segmentation of the input-image the filter needs an initial
        seed point. Therefore it has an argument from the type
        <emphasis>AddSeedType</emphasis>.</para>

        <para>This ensures that the generated processor has a GeometryPort as
        additional inport through which seed points can be added. To do this
        for example the SeedpointGenerator- or the VolumePicking processor can
        be used.</para>

        <programlisting>      &lt;filter name="ConfidenceConnectedImageFilter"&gt;
        &lt;arguments&gt;
          &lt;argument name="Seed" argumenttype="AddSeedType"/&gt;
          &lt;argument name="NumberOfIterations" argumenttype="Int" defaultValue="1" 
                    minValue="0" maxValue="1000"/&gt;
          &lt;argument name="ReplaceValue" argumenttype="PixelType"/&gt;
          &lt;argument name="Multiplier" argumenttype="Float" defaultValue="1.0f" 
                    minValue="1.0f" maxValue="1000.0f"/&gt;
          &lt;argument name="InitialNeighborhoodRadius" argumenttype="Int" defaultValue="1" 
                    minValue="0" maxValue="1000"/&gt;
        &lt;/arguments&gt;
      &lt;/filter&gt;</programlisting>
      </sect3>
    </sect2>

    <sect2>
      <title>Special Filters</title>

      <para>Although the ITK-Wrapper can generate a lot of filters
      automatically using the allready mentioned methods, there are still some
      filters which cannot be generated this way because they need for example
      an special input. This could be for example a special structure which
      cannot directly be represented by Voreen (e.g. a LabelMap), a special
      output from another filter or a special function.</para>

      <para>This section describes how the ITK-Wrapper can help to create
      these special filters (see 3.3.1) and how the created filters can then s
      be integrated into Voreen using the ITK-Wrapper (see 3.3.2).</para>

      <sect3>
        <title>Pre Generation of a special filter with the ITK-Wrapper</title>

        <para>As an example to explain how a special filter can be created we
        take a closer look at the <link
        ns6:href="http://www.itk.org/Doxygen/html/classitk_1_1LabelMapOverlayImageFilter.html">LabelMapContourOverlayImageFilter</link>.
        The special thing about this filter is, that it needs a <link
        ns6:href="http://www.itk.org/Doxygen/html/classitk_1_1LabelMap.html">LabelMap</link>
        as one input which is a special representation of an image that is not
        supported by Voreen. Therefore we need a second filter, e.g the <link
        ns6:href="http://www.itk.org/Doxygen/html/classitk_1_1BinaryImageToLabelMapFilter.html">BinaryImageToLabelMapFilter</link>,
        which can convert a "normal" image to a LabelMap and take it's output
        as input for the LabelMapContourOverlayImageFilter. This is not
        directly possible with the ITK-Wrapper but we can use the wrapper to
        pre generate a filter which can then be enhanced.</para>

        <para>As a first step we pre-define the filter with all needed ports
        and attributes in its module XML "ITKImageFusion" and let the wrapper
        generate a Voreen processor out of this definition:</para>

        <programlisting>&lt;?xml version="1.0" ?&gt;
&lt;VoreenData version="1"&gt;
  &lt;ITK_Module name="ITKImageFusion" group="Filtering"&gt;
    &lt;filterlist&gt;
      ...
      &lt;filter name="LabelMapContourOverlayImageFilter"&gt;
        &lt;inports&gt;
          &lt;port name="LabelImage"&gt;
            &lt;possibleTypes&gt;
              &lt;type value="IntegerScalar"/&gt;
            &lt;/possibleTypes&gt;
          &lt;/port&gt;
          &lt;port name="FeatureImage" nameIsSetter="true"&gt;
            &lt;possibleTypes&gt;
              &lt;type value="IntegerScalar"/&gt;
            &lt;/possibleTypes&gt;
          &lt;/port&gt;
        &lt;/inports&gt;
        &lt;outports&gt;
          &lt;port name="OutputImage"&gt;
            &lt;possibleTypes&gt;
              &lt;type value="3xInt16"/&gt;
            &lt;/possibleTypes&gt;
          &lt;/port&gt;
        &lt;/outports&gt;
        &lt;arguments&gt;
          &lt;argument name="Opacity" argumenttype="Float" defaultValue="0.5f" 
                    minValue="0.0f" maxValue="1.0f"/&gt;
        &lt;/arguments&gt;
      &lt;/filter&gt;
      ...
    &lt;/filterlist&gt;
  &lt;/ITK_Module&gt;
&lt;/VoreenData</programlisting>

        <para>The generated processor-.cpp then looks like this:</para>

        <itemizedlist>
          <listitem>
            <para>First there are some includes:</para>

            <programlisting>#include "labelmapcontouroverlayimagefilter.h"
#include "voreen/core/datastructures/volume/volume.h"
#include "voreen/core/datastructures/volume/volumehandle.h"
#include "voreen/core/datastructures/volume/volumeatomic.h"
#include "voreen/core/ports/conditions/portconditionvolumetype.h"
#include "modules/itk/utils/itkwrapper.h"
#include "voreen/core/datastructures/volume/operators/volumeoperatorconvert.h"
#include "itkImage.h"

#include "itkLabelMapContourOverlayImageFilter.h"

#include &lt;iostream&gt;</programlisting>
          </listitem>

          <listitem>
            <para>Then the two inputs and the output, represented through
            ports, and the attribute, represented through a property, are
            defined:</para>

            <programlisting>namespace voreen {

const std::string LabelMapContourOverlayImageFilterITK::
                  loggerCat_("voreen.LabelMapContourOverlayImageFilterITK");

LabelMapContourOverlayImageFilterITK::LabelMapContourOverlayImageFilterITK()
    : ITKProcessor(),
    inport1_(Port::INPORT, "LabelImage"),
    inport2_(Port::INPORT, "FeatureImage"),
    outport1_(Port::OUTPORT, "OutputImage"),
    opacity_("opacity", "Opacity", 0.5f, 0.0f, 1.0f)
{
    addPort(inport1_);
    PortConditionLogicalOr* orCondition1 = new PortConditionLogicalOr();
    orCondition1-&gt;addLinkedCondition(new PortConditionVolumeTypeUInt8());
    orCondition1-&gt;addLinkedCondition(new PortConditionVolumeTypeInt8());
    orCondition1-&gt;addLinkedCondition(new PortConditionVolumeTypeUInt16());
    orCondition1-&gt;addLinkedCondition(new PortConditionVolumeTypeInt16());
    orCondition1-&gt;addLinkedCondition(new PortConditionVolumeTypeUInt32());
    orCondition1-&gt;addLinkedCondition(new PortConditionVolumeTypeInt32());
    inport1_.addCondition(orCondition1);
    addPort(inport2_);
    PortConditionLogicalOr* orCondition2 = new PortConditionLogicalOr();
    orCondition2-&gt;addLinkedCondition(new PortConditionVolumeTypeUInt8());
    orCondition2-&gt;addLinkedCondition(new PortConditionVolumeTypeInt8());
    orCondition2-&gt;addLinkedCondition(new PortConditionVolumeTypeUInt16());
    orCondition2-&gt;addLinkedCondition(new PortConditionVolumeTypeInt16());
    orCondition2-&gt;addLinkedCondition(new PortConditionVolumeTypeUInt32());
    orCondition2-&gt;addLinkedCondition(new PortConditionVolumeTypeInt32());
    inport2_.addCondition(orCondition2);
    addPort(outport1_);

    addProperty(opacity_);
}

Processor* LabelMapContourOverlayImageFilterITK::create() const {
    return new LabelMapContourOverlayImageFilterITK();
}</programlisting>
          </listitem>

          <listitem>
            <para>After that the most important part follows, the
            labelMapContourOverlayImageFilterITK method which defines and
            performs the filter with the transferred
            template-arguments:</para>

            <para>Here first of all the image types of the two inputs and the
            output and two ITK SmartPointers which point to the input images
            are defined.</para>

            <programlisting>template&lt;class T, class S&gt;
void LabelMapContourOverlayImageFilterITK::labelMapContourOverlayImageFilterITK() {

    typedef itk::Image&lt;T, 3&gt; InputImageType1;
    typedef itk::Image&lt;S, 3&gt; InputImageType2;
    typedef itk::Image&lt;itk::CovariantVector&lt;int16_t,3&gt;, 3&gt; OutputImageType1;

    typename InputImageType1::Pointer p1 = voreenToITK&lt;T&gt;(inport1_.getData());
    typename InputImageType2::Pointer p2 = voreenToITK&lt;S&gt;(inport2_.getData());</programlisting>

            <para>Then the filter definition follows which will not work like
            this because the first template argument of the filter needs to be
            a TLabelMap and not a TImage. Therefore the following
            SetInput(p1)-command also won't work whereas the second input and
            the argument of the filter are set correctly.</para>

            <programlisting>    //Filter define
    typedef itk::LabelMapContourOverlayImageFilter&lt;InputImageType1, InputImageType2, 
                                                   OutputImageType1&gt; FilterType;
    typename FilterType::Pointer filter = FilterType::New();

    filter-&gt;SetInput(p1);
    filter-&gt;SetFeatureImage(p2);

    filter-&gt;SetOpacity(opacity_.get());</programlisting>

            <para>In the last part the filter is performed and the output is
            set.</para>

            <programlisting>    observe(filter.GetPointer());

    try
    {
        filter-&gt;Update();
    }
    catch (itk::ExceptionObject &amp;e)
    {
        LERROR(e);
    }

    VolumeHandle* outputVolume1 = 0;
    outputVolume1 = ITKVec3ToVoreenVec3Copy&lt;int16_t&gt;(filter-&gt;GetOutput());

    if (outputVolume1)
        outport1_.setData(outputVolume1);
    else
        outport1_.setData(0);
}</programlisting>
          </listitem>

          <listitem>
            <para>After that the processing-methods follow which validate the
            allowed volume types for the inputs and call the
            labelMapContourOverlayImageFilterITK method with the appropriate
            template-arguments.</para>

            <programlisting>void LabelMapContourOverlayImageFilterITK::process() {
    const VolumeHandleBase* inputHandle1 = inport1_.getData();
    const Volume* inputVolume1 = inputHandle1-&gt;getRepresentation&lt;Volume&gt;();
    
    if (dynamic_cast&lt;const VolumeUInt8*&gt;(inputVolume1))  {
        volumeTypeSwitch1&lt;uint8_t&gt;();
    }
    else if (dynamic_cast&lt;const VolumeInt8*&gt;(inputVolume1))  {
        volumeTypeSwitch1&lt;int8_t&gt;();
    }
    else if (dynamic_cast&lt;const VolumeUInt16*&gt;(inputVolume1))  {
        volumeTypeSwitch1&lt;uint16_t&gt;();
    }
    else if (dynamic_cast&lt;const VolumeInt16*&gt;(inputVolume1))  {
        volumeTypeSwitch1&lt;int16_t&gt;();
    }
    else if (dynamic_cast&lt;const VolumeUInt32*&gt;(inputVolume1))  {
        volumeTypeSwitch1&lt;uint32_t&gt;();
    }
    else if (dynamic_cast&lt;const VolumeInt32*&gt;(inputVolume1))  {
        volumeTypeSwitch1&lt;int32_t&gt;();
    }
    else {
        LERROR("Inputformat of Volume 1 is not supported!");
    }
}

template &lt;class T&gt;
void LabelMapContourOverlayImageFilterITK::volumeTypeSwitch1() {
    const VolumeHandleBase* inputHandle2 = inport2_.getData();
    const Volume* inputVolume2 = inputHandle2-&gt;getRepresentation&lt;Volume&gt;();
    
    if (dynamic_cast&lt;const VolumeUInt8*&gt;(inputVolume2))  {
        labelMapContourOverlayImageFilterITK&lt;T, uint8_t&gt;();
    }
    else if (dynamic_cast&lt;const VolumeInt8*&gt;(inputVolume2))  {
        labelMapContourOverlayImageFilterITK&lt;T, int8_t&gt;();
    }
    else if (dynamic_cast&lt;const VolumeUInt16*&gt;(inputVolume2))  {
        labelMapContourOverlayImageFilterITK&lt;T, uint16_t&gt;();
    }
    else if (dynamic_cast&lt;const VolumeInt16*&gt;(inputVolume2))  {
        labelMapContourOverlayImageFilterITK&lt;T, int16_t&gt;();
    }
    else if (dynamic_cast&lt;const VolumeUInt32*&gt;(inputVolume2))  {
        labelMapContourOverlayImageFilterITK&lt;T, uint32_t&gt;();
    }
    else if (dynamic_cast&lt;const VolumeInt32*&gt;(inputVolume2))  {
        labelMapContourOverlayImageFilterITK&lt;T, int32_t&gt;();
    }
    else {
        LERROR("Inputformat of Volume 2 is not supported!");
    }
}
}   // namespace</programlisting>
          </listitem>
        </itemizedlist>

        <para>And the generated processor.h looks like this:</para>

        <programlisting>#ifndef VRN_LABELMAPCONTOUROVERLAYIMAGEFILTER_H
#define VRN_LABELMAPCONTOUROVERLAYIMAGEFILTER_H

#include "modules/itk/processors/itkprocessor.h"
#include "voreen/core/processors/volumeprocessor.h"
#include "voreen/core/ports/allports.h"
#include &lt;string&gt;

#include "voreen/core/properties/floatproperty.h"

namespace voreen {

class VolumeHandleBase;

class LabelMapContourOverlayImageFilterITK : public ITKProcessor {
public:
    LabelMapContourOverlayImageFilterITK();

    virtual Processor* create() const;

    virtual std::string getCategory() const   { 
        return "Volume Processing/Filtering/ImageFusion"; 
    }
    virtual std::string getClassName() const  { 
        return "LabelMapContourOverlayImageFilterITK";  
    }
    virtual CodeState getCodeState() const    { 
        return CODE_STATE_EXPERIMENTAL; 
    }

protected:
    template&lt;class T, class S&gt;
    void labelMapContourOverlayImageFilterITK();

    virtual void process();
    template&lt;class T&gt;
    void volumeTypeSwitch1();

private:
    VolumePort inport1_;
    VolumePort inport2_;
    VolumePort outport1_;

    FloatProperty opacity_;

    static const std::string loggerCat_;
};
}
#endif</programlisting>

        <para>Now we enhance the processor.cpp by the following lines to make
        the filter work:</para>

        <itemizedlist>
          <listitem>
            <para>As mentioned above we need for example the <link
            ns6:href="http://www.itk.org/Doxygen/html/classitk_1_1BinaryImageToLabelMapFilter.html">BinaryImageToLabelMapFilter</link>
            to convert the first input image to a LabelMap. Therefore we need
            to include this filter first:</para>

            <programlisting>...
#include "itkLabelMapContourOverlayImageFilter.h"
<emphasis role="bold">#include "itkBinaryImageToLabelMapFilter.h"</emphasis>
...</programlisting>
          </listitem>

          <listitem>
            <para>Then this filter must be defined and convert the first input
            image to a LabelMap:</para>

            <programlisting>...
    typedef itk::Image&lt;T, 3&gt; InputImageType1;    
    typedef itk::Image&lt;S, 3&gt; InputImageType2;
    typedef itk::Image&lt;itk::CovariantVector&lt;T,3&gt;, 3&gt; OutputImageType1;

    typename InputImageType1::Pointer p1 = voreenToITK&lt;T&gt;(inport1_.getData());
    typename InputImageType2::Pointer p2 = voreenToITK&lt;S&gt;(inport2_.getData());

    <emphasis role="bold">typedef itk::BinaryImageToLabelMapFilter&lt;InputImageType1&gt; LabelMapType;</emphasis>
    <emphasis role="bold">LabelMapType::Pointer labelMap = LabelMapType::New();
    labelMap-&gt;SetInput(p1);
    labelMap-&gt;Update();</emphasis>

</programlisting>
          </listitem>

          <listitem>
            <para>After that the output of this filter can be used as input
            for the LabelMapContourOverlayImageFilter:</para>

            <programlisting>    //Filter define
    typedef itk::LabelMapContourOverlayImageFilter&lt;<emphasis role="bold">LabelMapType::OutputImageType</emphasis>, 
                                                   InputImageType2, 
                                                   OutputImageType1&gt; FilterType;
    typename FilterType::Pointer filter = FilterType::New();
      
    filter-&gt;SetInput(<emphasis role="bold">labelMap-&gt;GetOutput()</emphasis>);
    filter-&gt;SetFeatureImage(p2);

...</programlisting>
          </listitem>
        </itemizedlist>

        <para>After these changes the LabelMapContourOverlayImageFilter will
        work but it is also possible to add more things like for example a
        read only property that shows how many objects the filter has found in
        the image for a more comfortable analysis of the filter.</para>

        <para>Therefore additionally the following lines can be added to the
        .cpp-file:</para>

        <itemizedlist>
          <listitem>
            <para>First the new property-definition:</para>

            <programlisting>LabelMapContourOverlayImageFilterITK::LabelMapContourOverlayImageFilterITK()
    : ITKProcessor(),
    inport1_(Port::INPORT, "LabelMap"),
    inport2_(Port::INPORT, "FeatureImage"),
    outport1_(Port::OUTPORT, "OutputImage"),
    <emphasis role="bold">numObjects_("numObjects", "Number of Objects", 0, 0, 1000),</emphasis>
    opacity_("opacity", "Opacity", 0.0f, 0.f, 1.f)
{
    ...

    <emphasis role="bold">addProperty(numObjects_);
    numObjects_.setWidgetsEnabled(false);</emphasis>
    addProperty(opacity_);
}</programlisting>
          </listitem>

          <listitem>
            <para>And then the setting of this property:</para>

            <programlisting>    ...
    LabelMapType::Pointer labelMap = LabelMapType::New();
    labelMap-&gt;SetInput(p1);
    labelMap-&gt;Update();
    <emphasis role="bold">numObjects_.set(labelMap-&gt;GetOutput()-&gt;GetNumberOfLabelObjects());
    ...</emphasis></programlisting>
          </listitem>
        </itemizedlist>

        <para>... and to the .h-file:</para>

        <itemizedlist>
          <listitem>
            <para>The new IntProperty:</para>

            <programlisting>...

#include "voreen/core/properties/floatproperty.h"
<emphasis role="bold">#include "voreen/core/properties/intproperty.h"</emphasis>

namespace voreen {

class VolumeHandleBase;

class LabelMapContourOverlayImageFilterITK : public ITKProcessor {
...

private:
    VolumePort inport1_;
    VolumePort inport2_;
    VolumePort outport1_;

    <emphasis role="bold">IntProperty numObjects_;</emphasis>
    FloatProperty opacity_;

    static const std::string loggerCat_;
};
}
#endif</programlisting>
          </listitem>
        </itemizedlist>

        <para>Now the LabelMapContourOverlayImageFilter is complete and works
        for the moment. But there is still a problem:</para>

        <itemizedlist>
          <listitem>
            <para>The filter will be overwritten after running the ITK-Wrapper
            again!</para>
          </listitem>
        </itemizedlist>

        <para>The next section describes how to solve this problem.</para>
      </sect3>

      <sect3>
        <title>Integrating a special filter to Voreen with the
        ITK-Wrapper</title>

        <para>As mentioned in the last chapter we can use the ITK-Wrapper to
        pre generate a special filter and then enhance this filter. But if we
        run the wrapper again these enhancements will be lost. To prevent this
        you have to copy the filter's .cpp- and .h-file to the
        <filename>specialFilters</filename> directory (see section 2) where
        all special filters are stored.</para>

        <para>Apart from this you have to change the filter's definition in
        the "ITKImageFusion" xml like this:</para>

        <programlisting>...
      &lt;filter name="LabelMapContourOverlayImageFilter" <emphasis
            role="bold">autoGenerated="false"</emphasis>
              <emphasis role="bold">codeState ="STABLE"</emphasis>&gt;
      &lt;/filter&gt;
...</programlisting>

        <para>This has the effect that the ITK-Wrapper copies the
        processor-files of the filter from the specialFilters directory to
        it's module directory under
        "<filename>module/itk_generated/processors</filename>" and adds the
        filter to the <filename
        role="bold">itk_generatedmodule.cpp</filename>, the
        <filename>itk_generated_core.pri</filename> and the
        <filename>itk_generated_module.xml</filename>.</para>

        <para><emphasis role="bold">Note:</emphasis> The
        <emphasis>codeState</emphasis> will not be set by the wrapper if the
        filter's attribute <emphasis>autoGenerated</emphasis> is set to
        <emphasis>false</emphasis>. It is just set to have an overview of the
        code states of a module. So you have to set the codeState in the
        .h-file of the filter in the specialFilters directory on your
        own.</para>

        <para>After that you can run the ITK-Wrapper again without overwriting
        the new filter. </para>
      </sect3>
    </sect2>
  </sect1>
</article>
